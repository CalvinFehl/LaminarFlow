using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.InteropServices;
using UnityEngine;
using UnityEngine.Rendering;
using UnityEngine.Serialization;

namespace FluidFrenzy
{
	/// <summary>
	/// A GPU-accelerated particle system designed to efficiently spawn, simulate, and render large quantities of particles directly from compute or fragment shaders.
	/// </summary>
	/// <remarks>
	/// Unlike standard Unity particle systems, this system is optimized for high-density, performant interactions with the fluid simulation.
	/// <para>
	/// It is currently used to render interaction effects, such as steam generated when water mixes with lava, as well as dynamic hydraulic effects like splashes and spray generated by turbulent water.
	/// </para>
	/// </remarks>
	[Serializable]
	public class FluidParticleSystem
	{
		[SerializeField, HideInInspector]
		internal int version = 1;

		/// <summary>
		/// Defines the execution strategy for the particle update loop.
		/// </summary>
		public enum UpdateMode
		{
			/// <summary> Standard update loop independent of fluid data. </summary>
			Generic,
			/// <summary> Particles read data from the fluid simulation (e.g., for advection). </summary>
			ReadSimulation,
			/// <summary> Particles write data back to the fluid simulation. </summary>
			WriteSimulation
		}

		/// <summary>
		/// Configuration settings defining the physical behavior and visual appearance of emitted particles.
		/// </summary>
		/// <remarks>
		/// This structure controls parameters such as initial velocity, acceleration, color gradients, and lifetime randomization.
		/// </remarks>
		public ParticleEmitterDesc emitterDesc = ParticleEmitterDesc.Default;

		/// <summary>
		/// The maximum number of particles that can be active simultaneously in the simulation buffer.
		/// </summary>
		/// <remarks>
		/// This value determines the size of the GPU <see cref="GraphicsBuffer"/> allocated for the system. 
		/// Increasing this allows for denser effects but increases VRAM usage and GPU processing cost.
		/// </remarks>
		public int maxParticles = 100000;

		/// <summary>
		/// The material used to render the particle geometry.
		/// </summary>
		/// <remarks>
		/// <b>Requirement:</b> The assigned material must use a shader capable of procedural instantiation, such as the included <c>ProceduralParticle</c> or <c>ProceduralParticleUnlit</c> shaders.
		/// </remarks>
		public Material material;

		/// <summary>
		/// The Unity Layer index assigned to the rendered particles.
		/// </summary>
		/// <remarks>
		/// This is used to control visibility via Camera Culling Masks, allowing specific cameras (e.g., UI or reflection probes) to ignore these particles.
		/// </remarks>
		public int layer = 0;

		struct Particle
		{
			public Vector4 position;
			public Vector4 vel_accel_rot_angularvel;
			public Vector2 life_maxlife_color;
		};

#if UNITY_2021_1_OR_NEWER
		public GraphicsBuffer particleBuffer;
		public GraphicsBuffer freeParticleIndices;
		public GraphicsBuffer drawParticleIndices;
		public GraphicsBuffer emitterDescBuffer;
		private GraphicsBuffer m_drawArgs;
#else
		public ComputeBuffer particleBuffer;
		public ComputeBuffer freeParticleIndices;
		public ComputeBuffer drawParticleIndices;
		public ComputeBuffer emitterDescBuffer;
		private ComputeBuffer m_drawArgs;
#endif

		private ComputeShader m_particleEmitter;
		private int m_particleInitKernel;
		private int m_particleUpdateKernel;
		private int m_particleUpdateReadSimkernel;
		private int m_particleUpdateDepositSimkernel;

		private int m_updateKernel;

		private ParticleEmitterDesc[] m_emitterBuffer = new ParticleEmitterDesc[1];
		private FluidSimulation m_parentSimulation = null;

		public void Init(UpdateMode mode, FluidSimulation simulation)
		{
			m_parentSimulation = simulation;
			m_particleEmitter = Resources.Load("FluidParticleEmitter") as ComputeShader;
			m_particleInitKernel = m_particleEmitter.FindKernel("InitParticles");
			m_particleUpdateKernel = m_particleEmitter.FindKernel("UpdateParticle");
			m_particleUpdateReadSimkernel = m_particleEmitter.FindKernel("UpdateParticleReadSimulation");

			switch(mode)
			{
				case UpdateMode.Generic:
					m_updateKernel = m_particleUpdateKernel;
					break;				
				case UpdateMode.ReadSimulation:
					m_updateKernel = m_particleUpdateReadSimkernel;
					break;
			}

#if UNITY_2021_1_OR_NEWER
			emitterDescBuffer = new GraphicsBuffer(GraphicsBuffer.Target.Constant, 1, Marshal.SizeOf(typeof(ParticleEmitterDesc)));
			emitterDescBuffer.name = "emitter";
			emitterDescBuffer.SetData(new[] { emitterDesc });
			
			particleBuffer = new GraphicsBuffer(GraphicsBuffer.Target.Structured, maxParticles, Marshal.SizeOf(typeof(Particle)));
			freeParticleIndices = new GraphicsBuffer(GraphicsBuffer.Target.Structured, maxParticles + 1, sizeof(int));
			drawParticleIndices = new GraphicsBuffer(GraphicsBuffer.Target.Append | GraphicsBuffer.Target.CopySource | GraphicsBuffer.Target.CopyDestination, maxParticles, Marshal.SizeOf(typeof(uint)));
			drawParticleIndices.SetCounterValue(0);

			m_drawArgs = new GraphicsBuffer(GraphicsBuffer.Target.IndirectArguments, 5, Marshal.SizeOf(typeof(uint)));
#else
			emitterDescBuffer = new ComputeBuffer(1, Marshal.SizeOf(typeof(ParticleEmitterDesc)), ComputeBufferType.Constant);
			emitterDescBuffer.name = "emitter";
			emitterDescBuffer.SetData(new[] { emitterDesc });

			drawParticleIndices = new ComputeBuffer(maxParticles, Marshal.SizeOf(typeof(uint)), ComputeBufferType.Append);
			drawParticleIndices.SetCounterValue(0);
			particleBuffer = new ComputeBuffer(maxParticles, Marshal.SizeOf(typeof(Particle)), ComputeBufferType.Structured);
			freeParticleIndices = new ComputeBuffer(maxParticles + 1, sizeof(int));
			m_drawArgs = new ComputeBuffer(5, Marshal.SizeOf(typeof(uint)), ComputeBufferType.IndirectArguments);
#endif

			Reset();
		}

		public void Destroy()
		{
			particleBuffer.Dispose();
			freeParticleIndices.Dispose();
			drawParticleIndices.Dispose();
			emitterDescBuffer.Dispose();
			m_drawArgs.Dispose();
		}

		public void Reset()
		{
			drawParticleIndices.SetCounterValue(0);
			m_particleEmitter.GetKernelThreadGroupSizes(m_particleInitKernel, out uint threadCountX, out _, out _);
			m_particleEmitter.SetInt(FluidShaderProperties._ParticleCount, maxParticles);
			m_particleEmitter.SetBuffer(m_particleInitKernel, FluidShaderProperties._FreeIndices, freeParticleIndices);
			m_particleEmitter.SetBuffer(m_particleInitKernel, FluidShaderProperties._ParticleBuffer, particleBuffer);
			m_particleEmitter.SetBuffer(m_particleInitKernel, FluidShaderProperties._DrawArgs, m_drawArgs);
			m_particleEmitter.Dispatch(m_particleInitKernel, GraphicsHelpers.DCS(maxParticles, threadCountX), 1, 1);
		}

		public virtual void Process(CommandBuffer commandBuffer, float dt)
		{
			m_emitterBuffer[0] = emitterDesc;
			emitterDescBuffer.SetData(m_emitterBuffer);

			m_particleEmitter.GetKernelThreadGroupSizes(m_updateKernel, out uint threadCountX, out _, out _);
#if UNITY_2021_1_OR_NEWER
			commandBuffer.SetBufferCounterValue(drawParticleIndices, 0);
#else
			commandBuffer.SetComputeBufferCounterValue(drawParticleIndices, 0);
#endif
			commandBuffer.SetComputeIntParam(m_particleEmitter, FluidShaderProperties._ParticleCount, maxParticles);
			commandBuffer.SetComputeBufferParam(m_particleEmitter, m_updateKernel, FluidShaderProperties._FreeIndices, freeParticleIndices);
			commandBuffer.SetComputeBufferParam(m_particleEmitter, m_updateKernel, FluidShaderProperties._DrawIndices, drawParticleIndices);
			commandBuffer.SetComputeBufferParam(m_particleEmitter, m_updateKernel, FluidShaderProperties._ParticleBuffer, particleBuffer);
			if (m_parentSimulation)
			{
				commandBuffer.SetComputeVectorParam(m_particleEmitter, FluidShaderProperties._AdvectScale, m_parentSimulation.GetWorldVelocityScale());
				commandBuffer.SetComputeTextureParam(m_particleEmitter, m_updateKernel, FluidShaderProperties._SimulationData, m_parentSimulation.fluidRenderData);
			}
			commandBuffer.DispatchCompute(m_particleEmitter, m_updateKernel, GraphicsHelpers.DCS(maxParticles, threadCountX), 1, 1);
			commandBuffer.CopyCounterValue(drawParticleIndices, m_drawArgs, 4);
		}

		public void Render()
		{
			if (material)
			{
#if COZY_WEATHER
				if (ExternalHelpers.IsCozyWeatherFogEnabled())
				{
					material.EnableKeyword("_FLUID_COZY_FOG_FORWARD");
				}
				else
				{
					material.DisableKeyword("_FLUID_COZY_FOG_FORWARD");
				}
#endif

				material.SetBuffer(FluidShaderProperties._ParticleBuffer, particleBuffer);
				material.SetBuffer(FluidShaderProperties._DrawIndices, drawParticleIndices);
				material.SetMatrix(FluidShaderProperties._ParticleSystemObjectToWorld, m_parentSimulation.transform.localToWorldMatrix);


#if UNITY_2021_1_OR_NEWER
				RenderParams rp = new RenderParams()
				{
					receiveShadows = true,
					shadowCastingMode = ShadowCastingMode.Off,
					worldBounds = new Bounds(Vector3.zero, Vector3.one * 1000),
					lightProbeUsage = LightProbeUsage.BlendProbes,
					material = material,
					reflectionProbeUsage = ReflectionProbeUsage.Off,
					layer = layer,
					renderingLayerMask = uint.MaxValue,
				};

				Graphics.RenderPrimitivesIndirect(rp, MeshTopology.Triangles, m_drawArgs, 1);
#else
				Graphics.DrawProceduralIndirect(material, new Bounds(Vector3.zero, Vector3.one * 1000), MeshTopology.Triangles, m_drawArgs, 0);
#endif
			}
		}

		public void Render(CommandBuffer commandBuffer)
		{
#if UNITY_2021_1_OR_NEWER
			if (material)
			{
				material.SetBuffer(FluidShaderProperties._ParticleBuffer, particleBuffer);
				material.SetBuffer(FluidShaderProperties._DrawIndices, drawParticleIndices);
				material.SetMatrix(FluidShaderProperties._ParticleSystemObjectToWorld, m_parentSimulation.transform.localToWorldMatrix);

				int pass = 0;
#if FLUIDFRENZY_RUNTIME_HDRP_SUPPORT
				pass = material.FindPass("Forward");
				if (pass == -1)
					pass = material.FindPass("ForwardOnly");
#endif
				commandBuffer.DrawProceduralIndirect(Matrix4x4.identity, material, pass, MeshTopology.Triangles, m_drawArgs);
			}
#endif
			}

#if UNITY_6000_0_OR_NEWER && FLUIDFRENZY_RUNTIME_URP_SUPPORT
		public void Render(RasterCommandBuffer commandBuffer)
		{
			if (material)
			{
				material.SetBuffer(FluidShaderProperties._ParticleBuffer, particleBuffer);
				material.SetBuffer(FluidShaderProperties._DrawIndices, drawParticleIndices);
				material.SetMatrix(FluidShaderProperties._ObjectToWorld, m_parentSimulation.transform.localToWorldMatrix);
				commandBuffer.DrawProceduralIndirect(Matrix4x4.identity, material, 0, MeshTopology.Triangles, m_drawArgs);

			}
		}
#endif
		}
}