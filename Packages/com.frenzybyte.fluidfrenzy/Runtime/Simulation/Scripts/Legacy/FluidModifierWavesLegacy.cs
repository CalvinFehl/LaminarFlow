using System;
using System.Runtime.InteropServices;
using UnityEngine;
using UnityEngine.Experimental.Rendering;
using UnityEngine.Serialization;

namespace FluidFrenzy
{
	/// <summary>
	/// FluidModifierWaves applies a displacement force to the simulation to replicate waves generated by external forces like wind.
	/// </summary>
	[AddComponentMenu("")]
	public class FluidModifierWavesLegacy : FluidModifier
	{
		/// <summary>
		/// Settings that define a wave octave.
		/// </summary>
		[Serializable]
		public struct Wave
		{
			/// <summary> The number of waves. </summary>
			public float frequency;
			/// <summary> The height of the waves. </summary>
			public float amplitude;

			/// <summary> The speed the waves travel at. </summary>
			public float speed;
			/// <summary> The direction the waves travel in. </summary>
			public Vector2 direction;
		}

		private static int s_Property_PerlinNoiseScale = Shader.PropertyToID("_PerlinNoiseScale");
		private static int s_Property_BigWaves_frequency = Shader.PropertyToID("_BigWaves_frequency");
		private static int s_Property_BigWaves_amplitude = Shader.PropertyToID("_BigWaves_amplitude");
		private static int s_Property_BigWaves_speed = Shader.PropertyToID("_BigWaves_speed");
		private static int s_Property_BigWaves_direction = Shader.PropertyToID("_BigWaves_direction");

		private static int s_Property_SmallWaves_frequency = Shader.PropertyToID("_SmallWaves_frequency");
		private static int s_Property_SmallWaves_amplitude = Shader.PropertyToID("_SmallWaves_amplitude");
		private static int s_Property_SmallWaves_speed = Shader.PropertyToID("_SmallWaves_speed");
		private static int s_Property_SmallWaves_direction = Shader.PropertyToID("_SmallWaves_direction");

		private static int s_Property_NoiseWaves_frequency = Shader.PropertyToID("_NoiseWaves_frequency");
		private static int s_Property_NoiseWaves_amplitude = Shader.PropertyToID("_NoiseWaves_amplitude");
		private static int s_Property_NoiseWaves_speed = Shader.PropertyToID("_NoiseWaves_speed");
		private static int s_Property_NoiseWaves_direction = Shader.PropertyToID("_NoiseWaves_direction");
		private static int s_Property_Time = Shader.PropertyToID("_Time");

		/// <summary>
		/// The amount of force to be applied in regions where waves are being generated.
		/// </summary>
		public float strength = 1.0f;

		/// <summary>
		/// Defines the settings to generate random waves.
		/// </summary>
		public Wave octave1;
		/// <summary><inheritdoc cref="octave1"/></summary>
		public Wave octave2;
		/// <summary>
		/// Defines settings to create small up-and-down river-like waves. 
		/// This uses the input of Perlin noise to break up repetition.
		/// Each of these Waves has the following settings
		/// </summary>
		public Wave noiseOctave;

		/// <summary>
		/// The scale of the perlin noise mask used for <see cref="noiseOctave"/>.
		/// </summary>
		public float perlinNoiseScale = 25.0f;

		Material m_perlinNoiseMaterial;
		Material m_externalWavesMaterial;
		MaterialPropertyBlock m_externalWavesProperties;

		RenderTexture m_perlinNoise = null;
		RenderTexture m_waves = null;

		float m_time = 0;

		void Start()
		{
			m_perlinNoiseMaterial = new Material(Shader.Find("Hidden/FluidFrenzy/PerlinNoise"));
			m_externalWavesMaterial = new Material(Shader.Find("Hidden/FluidFrenzy/Legacy/Waves"));

#if UNITY_2023_2_OR_NEWER
			GraphicsFormat wavesFormat = SystemInfo.IsFormatSupported(GraphicsFormat.R8_SNorm, GraphicsFormatUsage.Render) ? GraphicsFormat.R8_SNorm : GraphicsFormat.R16_SFloat;
#else
			GraphicsFormat wavesFormat = SystemInfo.IsFormatSupported(GraphicsFormat.R8_SNorm, FormatUsage.Render) ? GraphicsFormat.R8_SNorm : GraphicsFormat.R16_SFloat;
#endif
			m_perlinNoise = new RenderTexture(256, 256, 0, wavesFormat);
			m_waves = new RenderTexture(256, 256, 0, wavesFormat);

			m_perlinNoiseMaterial.SetFloat(s_Property_PerlinNoiseScale, perlinNoiseScale);
			Graphics.Blit(null, m_perlinNoise, m_perlinNoiseMaterial);


			m_externalWavesProperties = new MaterialPropertyBlock();
			m_externalWavesProperties.SetFloat(s_Property_BigWaves_frequency, octave1.frequency);
			m_externalWavesProperties.SetFloat(s_Property_BigWaves_amplitude, octave1.amplitude);
			m_externalWavesProperties.SetFloat(s_Property_BigWaves_speed, octave1.speed);
			m_externalWavesProperties.SetVector(s_Property_BigWaves_direction, octave1.direction);

			m_externalWavesProperties.SetFloat(s_Property_SmallWaves_frequency, octave2.frequency);
			m_externalWavesProperties.SetFloat(s_Property_SmallWaves_amplitude, octave2.amplitude);
			m_externalWavesProperties.SetFloat(s_Property_SmallWaves_speed, octave2.speed);
			m_externalWavesProperties.SetVector(s_Property_SmallWaves_direction, octave2.direction);

			m_externalWavesProperties.SetFloat(s_Property_NoiseWaves_frequency, noiseOctave.frequency);
			m_externalWavesProperties.SetFloat(s_Property_NoiseWaves_amplitude, noiseOctave.amplitude);
			m_externalWavesProperties.SetFloat(s_Property_NoiseWaves_speed, noiseOctave.speed);
			m_externalWavesProperties.SetVector(s_Property_NoiseWaves_direction, noiseOctave.direction);
		}

		protected override void OnDestroy()
		{
			GraphicsHelpers.ReleaseSimulationRT(m_perlinNoise);
			GraphicsHelpers.ReleaseSimulationRT(m_waves);
			Destroy(m_perlinNoiseMaterial);
			Destroy(m_externalWavesMaterial);
			base.OnDestroy();
		}

		private void OnValidate()
		{
			if (!Application.isPlaying) return;

			m_externalWavesProperties = new MaterialPropertyBlock();
			m_externalWavesProperties.SetFloat(s_Property_BigWaves_frequency, octave1.frequency);
			m_externalWavesProperties.SetFloat(s_Property_BigWaves_amplitude, octave1.amplitude);
			m_externalWavesProperties.SetFloat(s_Property_BigWaves_speed, octave1.speed);
			m_externalWavesProperties.SetVector(s_Property_BigWaves_direction, octave1.direction);

			m_externalWavesProperties.SetFloat(s_Property_SmallWaves_frequency, octave2.frequency);
			m_externalWavesProperties.SetFloat(s_Property_SmallWaves_amplitude, octave2.amplitude);
			m_externalWavesProperties.SetFloat(s_Property_SmallWaves_speed, octave2.speed);
			m_externalWavesProperties.SetVector(s_Property_SmallWaves_direction, octave2.direction);

			m_externalWavesProperties.SetFloat(s_Property_NoiseWaves_frequency, noiseOctave.frequency);
			m_externalWavesProperties.SetFloat(s_Property_NoiseWaves_amplitude, noiseOctave.amplitude);
			m_externalWavesProperties.SetFloat(s_Property_NoiseWaves_speed, noiseOctave.speed);
			m_externalWavesProperties.SetVector(s_Property_NoiseWaves_direction, noiseOctave.direction);
		}

		public override void Process(FluidSimulation fluidSim, float dt)
		{
			m_externalWavesProperties.SetVector(s_Property_Time, new Vector4(m_time / 20, m_time, m_time * 2, m_time * 3));
			fluidSim.BlitQuadExternal(m_perlinNoise, m_waves, m_externalWavesMaterial, m_externalWavesProperties, 0);
			fluidSim.ApplyForce(m_waves, strength, dt);
			m_time += dt;
		}
	}
}