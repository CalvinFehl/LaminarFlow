using UnityEngine;
using UnityEditor;

namespace FluidFrenzy.Editor
{
	/// <summary>
	/// Custom Editor for the FluidRigidBody component.
	/// Provides a clean, organized, and well-documented interface in the Inspector.
	/// </summary>
	[CustomEditor(typeof(FluidRigidBody))]
	public class FluidRigidBodyEditor : UnityEditor.Editor
	{
		private static class Styles
		{
			public static readonly GUIContent showGridIcon = new GUIContent(
				EditorGUIUtility.IconContent("d_Mesh Icon").image,
				"Toggle Gizmo: Voxel Grid (Performance)\n\n" +
				"Shows the 3D grid used to group surface sample points for the fluid-to-solid (buoyancy) physics calculation. This is a crucial performance optimization.\n\n" +
				"The size of the grid cells is controlled by the 'Sampling Group Size' parameter. Use this visualization to tune the balance between performance (larger cells) and accuracy (smaller cells)."
			);

			public static readonly GUIContent showFluidToSolidPointsIcon = new GUIContent(
				EditorGUIUtility.IconContent("LightProbeProxyVolume Gizmo").image,
				"Toggle Gizmo: Surface Sample Points (Fluid -> Solid)\n\n" +
				"Shows the procedurally generated points used for calculating buoyancy, drag, and lift forces. " +
				"This visualizes where the fluid is applying forces TO this rigidbody (Requires Play Mode)."
			);

			public static readonly GUIContent showSolidToFluidPointsIcon = new GUIContent(
				EditorGUIUtility.IconContent("d_AnimatorStateMachine Icon").image,
				"Toggle Gizmo: Subdivided Displacement Mesh (Solid -> Fluid)\n\n" +
				"Shows the subdivided mesh triangles that are passed to the compute shader to displace the fluid. " +
				"This visualizes the geometry that creates splashes and wakes IN the water. (MeshColliders requires Play Mode)"
			);

			public static readonly GUIContent applyFluidDisplacementLabel = new GUIContent(
				"Enable Fluid Displacement",
				"A toggle for the solid-to-fluid interaction. If true, this object will displace the fluid, creating splashes and wakes."
			);
			public static readonly GUIContent applyFluidForcesToRigibodyLabel = new GUIContent(
				"Enable Buoyancy & Forces",
				"A toggle for the fluid-to-solid interaction. If true, the fluid will apply forces like buoyancy, drag, and lift to this object's Rigidbody."
			);

			public static readonly GUIContent subdivisionAreaThresholdLabel = new GUIContent(
				"Subdivision Area Threshold",
				@"The area threshold used to recursively subdivide a MeshCollider's triangles for the solid-to-fluid displacement pass.

Each triangle of the source mesh is checked against this value. If its area is larger, it is recursively split into four smaller sub-triangles until all resulting triangles are below this area. This creates a higher-density representation of the mesh, leading to more accurate and detailed fluid displacement (splashes and wakes). Lowering this value increases visual quality at the cost of higher memory usage (for the GraphicsBuffer) and GPU processing time."
			);

			public static readonly GUIContent heightInfluenceLabel = new GUIContent(
				"Height Influence",
				@"Controls how strongly the object's volume displaces the water's height. This is the primary factor in determining the size of waves generated by the object.

A higher value will cause the object to create larger waves and splashes upon impact, making it feel like it's displacing more water. A value of 0 would mean the object slices through the water without changing its height at all."
			);
			public static readonly GUIContent velocityInfluenceLabel = new GUIContent(
				"Velocity Influence",
				@"Controls how much of the object's velocity is transferred to the water, creating currents and wakes.

A higher value will cause the object to ""drag"" the water along with it more effectively, creating stronger currents in its wake. A value of 0 would mean the object moves through the water without affecting its velocity."
			);
			public static readonly GUIContent velocityScaleLabel = new GUIContent(
				"Velocity Scale",
				@"A multiplier that scales the velocity deltas. This acts as a global artistic control for the object's overall displacement.

This is a non-physical parameter useful for tuning the visual impact. You can use it to exaggerate or dampen an object's effect without altering the more physically-based ratio between its height and velocity displacement."
			);

			public static readonly GUIContent centerOfMassOffsetLabel = new GUIContent(
				"Center of Mass Offset",
				@"The custom center of mass for the Rigidbody ofset, calculated in local space.

By default, a Rigidbody's center of mass is at its geometric center, which is often too high for a boat, making it ""top-heavy"" and prone to capsizing in turns or rough water. By setting a negative Y value, you can artificially lower the center of mass, making the object ""bottom-heavy."" This creates a strong restoring torque that resists rolling and keeps the object upright, similar to the keel on a real boat."
			);

			public static readonly GUIContent dragCoefficientLabel = new GUIContent(
				"Drag Coefficient",
				@"The drag coefficient (CD), representing how much the fluid resists the object's motion through it. This is a dimensionless number that models the ""thickness"" or resistance of the fluid.

A higher value increases resistance, making the object feel like it's moving through a thicker substance (e.g., mud or honey). A lower value reduces resistance, making the object feel lighter and more slippery."
			);
			public static readonly GUIContent liftCoefficientLabel = new GUIContent(
				"Lift Coefficient",
				@"The lift coefficient (CL), representing the force generated perpendicular to the direction of fluid flow. This models how a surface's shape can act like a wing or a spoiler in the water.

This can create an upward force (like on a hydrofoil) or a downward force (like a spoiler on a race car) depending on the surface's angle relative to the flow. It's crucial for simulating dynamic, unstable behavior."
			);
			public static readonly GUIContent effectiveAreaWeightLabel = new GUIContent(
				"Effective Area Weight",
				@"The weighting factor that blends between using the full surface area and the projected area that directly faces the fluid flow.

A value of 0 means the object's orientation to the flow doesn't matter; it experiences the same drag from all sides. A value of 1 means only the surface area directly facing the flow contributes, making the object highly sensitive to its angle. A value of 0.5 provides a balanced mix."
			);

			public static readonly GUIContent samplingGroupSizeLabel = new GUIContent(
				"Sampling Group Size",
				@"The size of the grid cells used to group the object's surface points for optimization.

A performance tuning parameter that groups the object's surface points into a grid for optimized fluid sampling. Smaller values increase accuracy at a potential performance cost. A good starting value roughly matches the cell size of the fluid simulation."
			);

			public static readonly GUIContent sphereSamplesLabel = new GUIContent(
				"Sphere Sample Count",
				"Total number of sample points to generate on a SphereCollider's surface."
			);
			public static readonly GUIContent boxSamplesLabel = new GUIContent(
				"Box Samples Per Face-Axis",
				"Number of sample points to generate along each axis of a BoxCollider's face (e.g., 8 creates an 8x8 grid)."
			);
			public static readonly GUIContent capsuleSamplesLabel = new GUIContent(
				"Capsule Sample Count",
				"Total number of sample points to generate on a CapsuleCollider's surface."
			);
		}

		private SerializedProperty m_applyFluidDisplacement;
		private SerializedProperty m_displacementProfile;
		private SerializedProperty m_heightInfluence;
		private SerializedProperty m_velocityInfluence;
		private SerializedProperty m_velocityScale;
		private SerializedProperty m_subdivisionAreaThreshold;

		private SerializedProperty m_applyBuoyancy;
		private SerializedProperty m_centerOfMassOffset;
		private SerializedProperty m_interactionProfile;
		private SerializedProperty m_dragCoefficient;
		private SerializedProperty m_liftCoefficient;
		private SerializedProperty m_effectiveAreaWeight;
		private SerializedProperty m_samplingGroupSize;

		private SerializedProperty m_sphereSampleCount;
		private SerializedProperty m_boxFaceSampleCount;
		private SerializedProperty m_capsuleSampleCount;

		protected virtual void OnEnable()
		{
			// Find and cache all the serialized properties.
			m_applyFluidDisplacement = serializedObject.FindProperty("applyFluidDisplacement");
			m_subdivisionAreaThreshold = serializedObject.FindProperty("subdivisionAreaThreshold");
			m_displacementProfile = serializedObject.FindProperty("displacementProfile");
			m_heightInfluence = m_displacementProfile.FindPropertyRelative("heightInfluence");
			m_velocityInfluence = m_displacementProfile.FindPropertyRelative("velocityInfluence");
			m_velocityScale = m_displacementProfile.FindPropertyRelative("velocityScale");

			m_applyBuoyancy = serializedObject.FindProperty("applyFluidForcesToRigibody");
			m_centerOfMassOffset = serializedObject.FindProperty("centerOfMassOffset");
			m_interactionProfile = serializedObject.FindProperty("interactionProfile");
			m_dragCoefficient = m_interactionProfile.FindPropertyRelative("dragCoefficient");
			m_liftCoefficient = m_interactionProfile.FindPropertyRelative("liftCoefficient");
			m_effectiveAreaWeight = m_interactionProfile.FindPropertyRelative("effectiveAreaWeight");
			m_samplingGroupSize = serializedObject.FindProperty("samplingGroupSize");

			m_sphereSampleCount = serializedObject.FindProperty("sphereSampleCount");
			m_boxFaceSampleCount = serializedObject.FindProperty("boxFaceSampleCount");
			m_capsuleSampleCount = serializedObject.FindProperty("capsuleSampleCount");
		}

		public override void OnInspectorGUI()
		{
			serializedObject.Update();

			FluidRigidBody body = target as FluidRigidBody;

			EditorExtensions.DrawComputeUnsupportedWarning();

			EditorGUILayout.BeginHorizontal();
			GUILayout.FlexibleSpace(); // Pushes the toolbar to the right
			body.showVoxelGrid = GUILayout.Toggle(body.showVoxelGrid, Styles.showGridIcon, EditorStyles.miniButtonLeft, GUILayout.Width(50));
			body.showFluidToSolidSamplePoints = GUILayout.Toggle(body.showFluidToSolidSamplePoints, Styles.showFluidToSolidPointsIcon, EditorStyles.miniButtonRight, GUILayout.Width(50));
			body.showSolidToFluidSamplePoints = GUILayout.Toggle(body.showSolidToFluidSamplePoints, Styles.showSolidToFluidPointsIcon, EditorStyles.miniButtonRight, GUILayout.Width(50));
			EditorGUILayout.EndHorizontal();

			// Fluid Displacement
			if (EditorExtensions.DrawFoldoutHeaderToggle(m_applyFluidDisplacement, Styles.applyFluidDisplacementLabel))
			{
				EditorGUILayout.PropertyField(m_heightInfluence, Styles.heightInfluenceLabel);
				EditorGUILayout.PropertyField(m_velocityInfluence, Styles.velocityInfluenceLabel);
				EditorGUILayout.PropertyField(m_velocityScale, Styles.velocityScaleLabel);

				if (body.TryGetComponent<MeshCollider>(out _))
				{
					EditorGUILayout.PropertyField(m_subdivisionAreaThreshold, Styles.subdivisionAreaThresholdLabel);
				}
			}

			EditorGUILayout.Space();

			// Buoyancy and Forces
			if (EditorExtensions.DrawFoldoutHeaderToggle(m_applyBuoyancy, Styles.applyFluidForcesToRigibodyLabel))
			{
				EditorGUILayout.PropertyField(m_centerOfMassOffset, Styles.centerOfMassOffsetLabel);
				EditorGUILayout.PropertyField(m_dragCoefficient, Styles.dragCoefficientLabel);
				EditorGUILayout.PropertyField(m_liftCoefficient, Styles.liftCoefficientLabel);
				EditorGUILayout.PropertyField(m_effectiveAreaWeight, Styles.effectiveAreaWeightLabel);
				EditorGUILayout.PropertyField(m_samplingGroupSize, Styles.samplingGroupSizeLabel);

				if (body.TryGetComponent<SphereCollider>(out _))
				{
					EditorGUILayout.PropertyField(m_sphereSampleCount, Styles.sphereSamplesLabel);
				}
				else if (body.TryGetComponent<BoxCollider>(out _))
				{
					EditorGUILayout.PropertyField(m_boxFaceSampleCount, Styles.boxSamplesLabel);
				}
				else if (body.TryGetComponent<CapsuleCollider>(out _))
				{
					EditorGUILayout.PropertyField(m_capsuleSampleCount, Styles.capsuleSamplesLabel);
				}
			}

			EditorGUILayout.Space();

			serializedObject.ApplyModifiedProperties();
		}
	}
}